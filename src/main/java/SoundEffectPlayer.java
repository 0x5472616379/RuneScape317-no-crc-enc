import javax.sound.sampled.*;
import java.io.ByteArrayInputStream;

/**
 * Sound effect player for synthesized WAV sounds generated by SoundTrack.
 * Handles multiple simultaneous sound effects with delays.
 */
public class SoundEffectPlayer {

    private static final int MAX_SIMULTANEOUS_SOUNDS = 50;
    private static boolean initialized = false;
    private static AudioFormat audioFormat;
    private static SourceDataLine[] lines = new SourceDataLine[MAX_SIMULTANEOUS_SOUNDS];
    private static Thread[] playbackThreads = new Thread[MAX_SIMULTANEOUS_SOUNDS];
    private static int activeSlot = 0;
    private static float volumeGain = 1.0f; // 0.0 to 1.0

    /**
     * Sets the master volume for sound effects.
     * @param volumeDb Volume in decibels (0 = normal, -400/-800/-1200 = quieter, -10000 = mute)
     */
    public static void setVolume(int volumeDb) {
        // Convert decibels to gain (0.0 to 1.0)
        // volumeDb is in range like -1200 to 0
        if (volumeDb <= -10000) {
            volumeGain = 0.0f; // Muted
        } else {
            volumeGain = (float) Math.pow(10.0, volumeDb / 200.0 / 20.0);
            volumeGain = Math.max(0.0f, Math.min(1.0f, volumeGain));
        }

        System.out.println("Sound effect volume set to: " + volumeDb + "db (gain: " + volumeGain + ")");
    }

    /**
     * Initializes the sound effect player.
     */
    public static void init() {
        if (initialized) {
            return;
        }

        try {
            // SoundTrack generates 22050 Hz, 8-bit, mono, unsigned
            audioFormat = new AudioFormat(
                    22050f,       // sample rate
                    8,                      // bits per sample
                    1,                      // channels (mono)
                    false,                  // signed = false (unsigned)
                    false                   // big endian = false (little endian)
            );

            System.out.println("Sound effect player initialized");
            System.out.println("Format: " + audioFormat);
            initialized = true;

        } catch (Exception e) {
            System.err.println("Failed to initialize sound player: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Plays a synthesized sound effect.
     *
     * @param soundID The sound ID from SoundTrack
     * @param loopCount Number of times to loop the sound
     * @param delayMs Delay in milliseconds before playing
     */
    public static void play(int soundID, int loopCount, int delayMs) {
        if (!initialized) {
            init();
        }

        if (!initialized) {
            return;
        }

        // Find next available slot
        int slot = findAvailableSlot();
        if (slot == -1) {
            System.err.println("No available sound slots (max 50 concurrent sounds)");
            return;
        }

        // Generate the WAV data
        Buffer waveBuffer = SoundTrack.generate(loopCount, soundID);
        if (waveBuffer == null) {
            System.err.println("Failed to generate sound " + soundID);
            return;
        }

        // Extract the audio data (skip 44-byte WAV header)
        byte[] wavData = new byte[waveBuffer.position];
        System.arraycopy(SoundTrack.waveBytes, 0, wavData, 0, waveBuffer.position);

        // Play in a separate thread
        playbackThreads[slot] = new Thread(() -> {
            playSound(slot, wavData, delayMs, soundID);
        });
        playbackThreads[slot].setDaemon(true);
        playbackThreads[slot].start();
    }

    /**
     * Finds an available playback slot.
     */
    private static int findAvailableSlot() {
        for (int i = 0; i < MAX_SIMULTANEOUS_SOUNDS; i++) {
            if (playbackThreads[i] == null || !playbackThreads[i].isAlive()) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Plays a sound in the given slot.
     */
    private static void playSound(int slot, byte[] wavData, int delayMs, int soundID) {
        SourceDataLine line = null;

        try {
            // Apply delay
            if (delayMs > 0) {
                Thread.sleep(delayMs);
            }

            // Open audio line
            DataLine.Info info = new DataLine.Info(SourceDataLine.class, audioFormat);
            line = (SourceDataLine) AudioSystem.getLine(info);
            lines[slot] = line;

            line.open(audioFormat);
            line.start();

            // Write audio data (skip 44-byte WAV header)
            int dataLength = wavData.length - 44;
            if (dataLength > 0) {
                // Apply volume by modifying the audio data
                byte[] volumeAdjusted = new byte[dataLength];
                for (int i = 0; i < dataLength; i++) {
                    // Convert unsigned byte (0-255) to signed (-128 to 127)
                    int sample = (wavData[44 + i] & 0xFF) - 128;
                    // Apply volume
                    sample = (int) (sample * volumeGain);
                    // Convert back to unsigned byte
                    volumeAdjusted[i] = (byte) ((sample + 128) & 0xFF);
                }

                line.write(volumeAdjusted, 0, dataLength);
            }

            // Wait for playback to complete
            line.drain();
            line.stop();
            line.close();

            lines[slot] = null;

        } catch (InterruptedException e) {
            // Thread was interrupted, clean up
            if (line != null && line.isOpen()) {
                line.stop();
                line.close();
            }
        } catch (Exception e) {
            System.err.println("Error playing sound " + soundID + ": " + e.getMessage());
            e.printStackTrace();

            if (line != null && line.isOpen()) {
                line.stop();
                line.close();
            }
        }
    }

    /**
     * Stops all currently playing sounds.
     */
    public static void stopAll() {
        for (int i = 0; i < MAX_SIMULTANEOUS_SOUNDS; i++) {
            if (lines[i] != null && lines[i].isOpen()) {
                lines[i].stop();
                lines[i].close();
                lines[i] = null;
            }

            if (playbackThreads[i] != null && playbackThreads[i].isAlive()) {
                playbackThreads[i].interrupt();
                playbackThreads[i] = null;
            }
        }

        System.out.println("All sound effects stopped");
    }

    /**
     * Cleans up resources.
     */
    public static void cleanup() {
        stopAll();
        initialized = false;
        System.out.println("Sound effect player cleaned up");
    }
}